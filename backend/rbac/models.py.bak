"""
Role-Based Access Control Models
Legacy RBAC infrastructure models. Device Group RBAC has been moved to devices app.
"""

from django.db import models
from django.contrib.auth.models import User
from django.contrib.auth.models import Group as AuthGroup
from core.models import Label


class Permission(models.Model):
    """
    Permission Model: Granular actions users can perform
    
    Fields:
        - code (CharField): Unique permission identifier (e.g., "view_devices", "edit_credentials")
        - description (TextField): Human-readable explanation
    
    Methods:
        - __str__(): Returns the permission code
    
    Permission Examples:
        - view_devices: Can view device list
        - edit_devices: Can create and modify devices
        - delete_devices: Can delete devices
        - manage_credentials: Can view and edit credentials
        - admin_access: Full administrative access
    
    Usage:
        Permissions are assigned to roles, which are assigned to users.
        Granular control allows precise access management.
    """
    code = models.CharField(max_length=128, unique=True, help_text='Unique permission identifier')
    description = models.TextField(blank=True, help_text='Description of what this permission allows')
    
    def __str__(self):
        """Return permission code for admin display"""
        return self.code


class Role(models.Model):
    """
    Role Model: Groups permissions and label scopes for access control
    
    Fields:
        - name (CharField): Unique role name (e.g., "Administrator", "Operator")
        - permissions (ManyToManyField): Permissions assigned to this role
        - labels (ManyToManyField): Labels this role can access (multi-tenancy support)
    
    Methods:
        - __str__(): Returns the role name
    
    Role Examples:
        - Administrator: All permissions, all labels
        - Operator: View/manage devices and backups, limited to assigned labels
        - Viewer: Read-only access to devices and backups
    
    Usage:
        Roles bundle permissions and label scopes together.
        Users are assigned roles to determine what they can do and what data they can access.
    """
    name = models.CharField(max_length=64, unique=True, help_text='Unique role name')
    permissions = models.ManyToManyField(Permission, blank=True, help_text='Permissions granted to users with this role')
    labels = models.ManyToManyField(Label, blank=True, help_text='Labels/environments this role can access')
    
    def __str__(self):
        """Return role name for admin display"""
        return self.name


class UserRole(models.Model):
    """
    UserRole Model: Associates users with roles
    
    Fields:
        - user (ForeignKey): User being assigned a role
        - role (ForeignKey): Role to assign to user
    
    Constraints:
        - Each user-role pair is unique (no duplicate assignments)
    
    Usage:
        Users can have multiple roles. Each role grants permissions and label scopes.
        When checking access, all user's roles are evaluated to determine final permissions.
    
    Examples:
        - User "john" has role "Administrator" → full access
        - User "jane" has roles "Operator" (Production), "Operator" (Development) 
          → can manage devices in both environments
    """
    user = models.ForeignKey(User, on_delete=models.CASCADE, help_text='User being assigned a role')
    role = models.ForeignKey(Role, on_delete=models.CASCADE, help_text='Role to assign')
    
    class Meta:
        unique_together = ('user', 'role')


class GroupLabelAssignment(models.Model):
    """
    Maps Django auth Group to Label (tags assigned to a group).

    Constraints:
        - Unique (group, label) pairs
    """
    group = models.ForeignKey(AuthGroup, on_delete=models.CASCADE, related_name='label_assignments')
    label = models.ForeignKey(Label, on_delete=models.CASCADE, related_name='group_assignments')
    assigned_at = models.DateTimeField(auto_now_add=True, help_text='When the label was assigned to the group')

    class Meta:
        unique_together = ('group', 'label')
        verbose_name = 'Group Label Assignment'
        verbose_name_plural = 'Group Label Assignments'

    def __str__(self):
        return f"{self.group.name} -> {self.label.name}"


class DeviceGroup(models.Model):
    """
    DeviceGroup Model: Organizes devices into logical groups for RBAC
    
    Fields:
        - name (CharField): Unique device group name (e.g., "Production Routers", "DMZ Firewalls")
        - description (TextField): Optional description of the group's purpose
        - created_at (DateTimeField): When group was created
        - updated_at (DateTimeField): When group was last modified
    
    Methods:
        - __str__(): Returns the device group name
    
    Usage:
        Device groups replace local labels/tags for organizing devices.
        Each device is assigned to exactly one device group.
        Roles are granted permissions to device groups (view, edit, add device, delete device, etc.)
        Users/groups with these roles can perform the allowed actions on devices in that group.
    """
    name = models.CharField(max_length=128, unique=True, help_text='Unique device group name')
    description = models.TextField(blank=True, help_text='Description of the device group purpose')
    created_at = models.DateTimeField(auto_now_add=True, help_text='When group was created')
    updated_at = models.DateTimeField(auto_now=True, help_text='When group was last modified')
    
    def __str__(self):
        """Return device group name for admin display"""
        return self.name

    def save(self, *args, **kwargs):
        # Ensure name is clean and not padded with whitespace
        if self.name is not None:
            self.name = self.name.strip()
        super().save(*args, **kwargs)


class DeviceGroupDjangoPermissions(models.Model):
    """
    Maps a DeviceGroup to its corresponding Django auth Permissions that follow
    the naming convention on codename: "rbac_dg_<slug>_<add|change|delete|view>".

    Name is human-friendly: e.g., "Device Group 'Production': add".
    """
    device_group = models.OneToOneField(DeviceGroup, on_delete=models.CASCADE, related_name='django_permissions')
    perm_add = models.ForeignKey(AuthPermission, on_delete=models.CASCADE, related_name='dg_perm_add')
    perm_change = models.ForeignKey(AuthPermission, on_delete=models.CASCADE, related_name='dg_perm_change')
    perm_delete = models.ForeignKey(AuthPermission, on_delete=models.CASCADE, related_name='dg_perm_delete')
    perm_view = models.ForeignKey(AuthPermission, on_delete=models.CASCADE, related_name='dg_perm_view')

    def __str__(self):
        return f"RBAC|DG_{self.device_group.name}"

    @staticmethod
    def slugify_name(group_name: str) -> str:
        import re
        slug = group_name.strip().lower()
        slug = re.sub(r"[^a-z0-9]+", "_", slug)
        slug = re.sub(r"_+", "_", slug).strip('_')
        return slug or "group"

    @classmethod
    def ensure_for_group(cls, device_group: DeviceGroup):
        slug = cls.slugify_name(device_group.name)
        ct = ContentType.objects.get_for_model(DeviceGroup)
        perms = {}
        for action in ("add", "change", "delete", "view"):
            codename = f"rbac_dg_{slug}_{action}"
            name = f"{device_group.name}: {action}"
            perm, _ = AuthPermission.objects.get_or_create(codename=codename, content_type=ct, defaults={"name": name})
            # If name drifted, refresh it to reflect current group name
            if perm.name != name:
                perm.name = name
                perm.save(update_fields=["name"])
            perms[action] = perm
        instance, _ = cls.objects.get_or_create(
            device_group=device_group,
            defaults={
                'perm_add': perms['add'],
                'perm_change': perms['change'],
                'perm_delete': perms['delete'],
                'perm_view': perms['view'],
            }
        )
        updated = False
        if instance.perm_add_id != perms['add'].id:
            instance.perm_add = perms['add']; updated = True
        if instance.perm_change_id != perms['change'].id:
            instance.perm_change = perms['change']; updated = True
        if instance.perm_delete_id != perms['delete'].id:
            instance.perm_delete = perms['delete']; updated = True
        if instance.perm_view_id != perms['view'].id:
            instance.perm_view = perms['view']; updated = True
        if updated:
            instance.save(update_fields=['perm_add','perm_change','perm_delete','perm_view'])
        return instance

    def rename_to(self, new_group_name: str):
        """Update the human-readable permission names to reflect new group name."""
        for action, perm in (('add', self.perm_add), ('change', self.perm_change), ('delete', self.perm_delete), ('view', self.perm_view)):
            expected = f"{new_group_name}: {action}"
            if perm.name != expected:
                perm.name = expected
                perm.save(update_fields=['name'])

    def has_any_holders(self) -> bool:
        # Any users with these permissions directly assigned
        if self.perm_add.user_set.exists() or self.perm_change.user_set.exists() or self.perm_delete.user_set.exists() or self.perm_view.user_set.exists():
            return True
        # Any groups with these permissions assigned
        if self.perm_add.group_set.exists() or self.perm_change.group_set.exists() or self.perm_delete.group_set.exists() or self.perm_view.group_set.exists():
            return True
        # Also consider our own role assignments as usage of this device group
        if UserDeviceGroupRole.objects.filter(role__device_group=self.device_group).exists():
            return True
        if GroupDeviceGroupRole.objects.filter(role__device_group=self.device_group).exists():
            return True
        return False


# --- Signals to keep Django roles in sync with DeviceGroup lifecycle ---

@receiver(post_save, sender=DeviceGroup)
def ensure_django_permissions_on_save(sender, instance: DeviceGroup, created, **kwargs):
    # Always ensure permissions exist and reflect current group name
    link = DeviceGroupDjangoPermissions.ensure_for_group(instance)
    link.rename_to(instance.name)

@receiver(pre_delete, sender=DeviceGroup)
def prevent_delete_if_permissions_in_use(sender, instance: DeviceGroup, **kwargs):
    try:
        link = instance.django_permissions
    except DeviceGroupDjangoPermissions.DoesNotExist:
        return  # No mapping; allow deletion
    if link.has_any_holders():
        from django.core.exceptions import ValidationError
        raise ValidationError('Cannot delete device group: related Django permissions are assigned to users or groups.')


class DeviceGroupPermission(models.Model):
    """
    DeviceGroupPermission Model: Granular permissions for device group operations
    
    Fields:
        - code (CharField): Unique permission code (e.g., "view_config", "view_backups", "edit_config", etc.)
        - description (TextField): Description of what this permission allows
    
    Permission Codes:
        - view_configuration: Can view device configuration backups
        - view_backups: Can view/download backup history
        - edit_configuration: Can modify device configuration
        - add_device: Can add devices to the group
        - delete_device: Can delete devices from the group
        - enable_device: Can enable/disable devices in the group
    """
    code = models.CharField(max_length=128, unique=True, help_text='Unique permission code')
    description = models.TextField(blank=True, help_text='Description of what this permission allows')
    
    def __str__(self):
        """Return permission code for admin display"""
        return self.code


class DeviceGroupRole(models.Model):
    """
    DeviceGroupRole Model: Roles for managing access to device groups
    
    Fields:
        - name (CharField): Role name (e.g., "Operator", "Viewer", "Admin")
        - device_group (ForeignKey): Which device group this role applies to
        - permissions (ManyToManyField): Permissions granted by this role
        - created_at (DateTimeField): When role was created
    
    Methods:
        - __str__(): Returns role name with device group
    
    Usage:
        Roles are created per device group and grant specific permissions.
        Users and auth groups are then assigned these roles to control their access.
    """
    name = models.CharField(max_length=128, help_text='Role name within the device group')
    device_group = models.ForeignKey(DeviceGroup, on_delete=models.CASCADE, related_name='roles', help_text='Device group this role applies to')
    permissions = models.ManyToManyField(DeviceGroupPermission, blank=True, help_text='Permissions granted by this role')
    created_at = models.DateTimeField(auto_now_add=True, help_text='When role was created')
    
    class Meta:
        unique_together = ('name', 'device_group')
        verbose_name = 'Device Group Role'
        verbose_name_plural = 'Device Group Roles'
    
    def __str__(self):
        """Return role name with device group"""
        return f"{self.name} ({self.device_group.name})"


class UserDeviceGroupRole(models.Model):
    """
    UserDeviceGroupRole Model: Assigns device group roles to users
    
    Fields:
        - user (ForeignKey): User being assigned a role
        - role (ForeignKey): Device group role to assign
    
    Constraints:
        - Each user-role pair is unique (no duplicate assignments)
    
    Usage:
        Users are assigned roles for specific device groups.
        A user can have different roles for different device groups.
    """
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='device_group_roles', help_text='User being assigned a role')
    role = models.ForeignKey(DeviceGroupRole, on_delete=models.CASCADE, help_text='Device group role to assign')
    
    class Meta:
        unique_together = ('user', 'role')
        verbose_name = 'User Device Group Role'
        verbose_name_plural = 'User Device Group Roles'
    
    def __str__(self):
        """Return descriptive string"""
        return f"{self.user.username} -> {self.role}"


class GroupDeviceGroupRole(models.Model):
    """
    GroupDeviceGroupRole Model: Assigns device group roles to Django auth groups
    
    Fields:
        - auth_group (ForeignKey): Django auth group
        - role (ForeignKey): Device group role to assign
    
    Constraints:
        - Each auth_group-role pair is unique (no duplicate assignments)
    
    Usage:
        Auth groups are assigned roles for specific device groups.
        All users in the auth group inherit the role and its permissions.
        This allows bulk assignment of device group access.
    """
    auth_group = models.ForeignKey(AuthGroup, on_delete=models.CASCADE, related_name='device_group_roles', help_text='Django auth group')
    role = models.ForeignKey(DeviceGroupRole, on_delete=models.CASCADE, help_text='Device group role to assign')
    
    class Meta:
        unique_together = ('auth_group', 'role')
        verbose_name = 'Group Device Group Role'
        verbose_name_plural = 'Group Device Group Roles'
    
    def __str__(self):
        """Return descriptive string"""
        return f"{self.auth_group.name} -> {self.role}"
